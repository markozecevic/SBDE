{
  "sbg:project": "marko_zecevic/sbde1",
  "sbg:canvas_x": 1,
  "steps": [
    {
      "sbg:y": 61.15620930989584,
      "run": {
        "baseCommand": [
          "java",
          {
            "script": "{   \n  if($job.inputs.memory_per_job){\n    return '-Xmx'.concat($job.inputs.memory_per_job, 'M')\n  }   \n  \treturn '-Xmx2048M'\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          },
          "-jar",
          "/opt/picard-tools-1.140/picard.jar",
          "SortSam"
        ],
        "sbg:project": "sevenbridges/public-apps",
        "sbg:contributors": [
          "sevenbridges"
        ],
        "x": 1006.1109076605903,
        "sbg:categories": [
          "SAM/BAM-Processing"
        ],
        "temporaryFailCodes": [],
        "sbg:toolkitVersion": "1.140",
        "label": "Picard SortSam",
        "outputs": [
          {
            "sbg:fileTypes": "BAM, SAM",
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_bam",
              "sbg:metadata": {
                "__inherit__": "input_bam"
              },
              "glob": "*.sorted.?am",
              "secondaryFiles": [
                "^.bai",
                ".bai"
              ]
            },
            "description": "Sorted BAM or SAM file.",
            "label": "Sorted BAM/SAM",
            "id": "#sorted_bam",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:toolAuthor": "Broad Institute",
        "sbg:id": "admin/sbg-public-data/picard-sortsam-1-140/2",
        "sbg:latestRevision": 2,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 2048
          },
          "inputs": {
            "sort_order": "Coordinate",
            "memory_per_job": 2048,
            "input_bam": {
              "path": "/root/dir/example.tested.bam"
            },
            "output_type": null,
            "create_index": null
          }
        },
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "eab0e70b6629",
            "dockerPull": "images.sbgenomics.com/mladenlsbg/picard:1.140"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": {
              "script": "{\n  if($job.inputs.memory_per_job){\n  \treturn $job.inputs.memory_per_job\n  }\n  \treturn 2048\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "class": "sbg:MemRequirement"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 0,
            "sbg:modifiedOn": 1453798823
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 1,
            "sbg:modifiedOn": 1453798824
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 2,
            "sbg:modifiedOn": 1453798826
          }
        ],
        "sbg:license": "MIT License, Apache 2.0 Licence",
        "stdin": "",
        "sbg:createdOn": 1453798823,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "description": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}.",
            "label": "Validation stringency",
            "sbg:toolDefaultValue": "SILENT",
            "id": "#validation_stringency",
            "sbg:category": "Other input types",
            "type": [
              "null",
              {
                "symbols": [
                  "STRICT",
                  "LENIENT",
                  "SILENT"
                ],
                "type": "enum",
                "name": "validation_stringency"
              }
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "VALIDATION_STRINGENCY=",
              "valueFrom": {
                "script": "{\n  if ($job.inputs.validation_stringency)\n  {\n    return $job.inputs.validation_stringency\n  }\n  else\n  {\n    return \"SILENT\"\n  }\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sort order of the output file. Possible values: {unsorted, queryname, coordinate}.",
            "sbg:altPrefix": "SO",
            "label": "Sort order",
            "sbg:toolDefaultValue": "Coordinate",
            "id": "#sort_order",
            "sbg:category": "Other input types",
            "type": [
              {
                "symbols": [
                  "Unsorted",
                  "Queryname",
                  "Coordinate"
                ],
                "type": "enum",
                "name": "sort_order"
              }
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "SORT_ORDER=",
              "position": 3,
              "valueFrom": {
                "script": "{\n  p = $job.inputs.sort_order.toLowerCase()\n  return p\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "This parameter indicates whether to suppress job-summary info on System.err. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "label": "Quiet",
            "sbg:toolDefaultValue": "False",
            "id": "#quiet",
            "sbg:category": "Other input types",
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "type": "enum",
                "name": "quiet"
              }
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "QUIET=",
              "sbg:cmdInclude": true
            }
          },
          {
            "type": [
              "null",
              {
                "symbols": [
                  "BAM",
                  "SAM",
                  "SAME AS INPUT"
                ],
                "type": "enum",
                "name": "output_type"
              }
            ],
            "label": "Output format",
            "sbg:toolDefaultValue": "SAME AS INPUT",
            "id": "#output_type",
            "sbg:category": "Other input types",
            "description": "Since Picard tools can output both SAM and BAM files, user can choose the format of the output file."
          },
          {
            "sbg:toolDefaultValue": "2048",
            "id": "#memory_per_job",
            "description": "Amount of RAM memory to be used per job. Defaults to 2048 MB for single threaded jobs.",
            "type": [
              "null",
              "int"
            ],
            "label": "Memory per job"
          },
          {
            "description": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. This option can be set to 'null' to clear the default value.",
            "label": "Max records in RAM",
            "sbg:toolDefaultValue": "500000",
            "id": "#max_records_in_ram",
            "sbg:category": "Other input types",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "MAX_RECORDS_IN_RAM=",
              "sbg:cmdInclude": true
            }
          },
          {
            "required": true,
            "sbg:fileTypes": "BAM, SAM",
            "description": "The BAM or SAM file to sort.",
            "sbg:altPrefix": "I",
            "label": "Input BAM",
            "id": "#input_bam",
            "sbg:category": "File inputs",
            "type": [
              "File"
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "INPUT=",
              "position": 1,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "This parameter indicates whether to create a BAM index when writing a coordinate-sorted BAM file. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
            "label": "Create index",
            "sbg:toolDefaultValue": "False",
            "id": "#create_index",
            "sbg:category": "Other input types",
            "type": [
              "null",
              {
                "symbols": [
                  "True",
                  "False"
                ],
                "type": "enum",
                "name": "create_index"
              }
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "CREATE_INDEX=",
              "position": 5,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Compression level for all compressed files created (e.g. BAM and GELI). This option can be set to 'null' to clear the default value.",
            "label": "Compression level",
            "sbg:toolDefaultValue": "5",
            "id": "#compression_level",
            "sbg:category": "Other input types",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "prefix": "COMPRESSION_LEVEL=",
              "sbg:cmdInclude": true
            }
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:links": [
          {
            "id": "http://broadinstitute.github.io/picard/index.html",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/broadinstitute/picard/releases/tag/1.138",
            "label": "Source Code"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Wiki"
          },
          {
            "id": "https://github.com/broadinstitute/picard/zipball/master",
            "label": "Download"
          },
          {
            "id": "http://broadinstitute.github.io/picard/",
            "label": "Publication"
          }
        ],
        "sbg:validationErrors": [],
        "description": "Picard SortSam sorts the input SAM or BAM. Input and output formats are determined by the file extension.",
        "stdout": "",
        "sbg:createdBy": "sevenbridges",
        "sbg:modifiedOn": 1453798826,
        "sbg:cmdPreview": "java -Xmx2048M -jar /opt/picard-tools-1.140/picard.jar SortSam OUTPUT=example.tested.sorted.bam INPUT=/root/dir/example.tested.bam SORT_ORDER=coordinate   INPUT=/root/dir/example.tested.bam SORT_ORDER=coordinate  /root/dir/example.tested.bam",
        "sbg:modifiedBy": "sevenbridges",
        "sbg:revision": 2,
        "id": "admin/sbg-public-data/picard-sortsam-1-140/2",
        "y": 61.15620930989584,
        "arguments": [
          {
            "separate": false,
            "order": 2,
            "valueFrom": {
              "script": "{\n  filename = $job.inputs.input_bam.path\n  ext = $job.inputs.output_type\n\nif (ext === \"BAM\")\n{\n    return filename.split('.').slice(0, -1).concat(\"sorted.bam\").join(\".\").replace(/^.*[\\\\\\/]/, '')\n    }\n\nelse if (ext === \"SAM\")\n{\n    return filename.split('.').slice(0, -1).concat(\"sorted.sam\").join('.').replace(/^.*[\\\\\\/]/, '')\n}\n\nelse \n{\n\treturn filename.split('.').slice(0, -1).concat(\"sorted.\"+filename.split('.').slice(-1)[0]).join(\".\").replace(/^.*[\\\\\\/]/, '')\n}\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "prefix": "OUTPUT=",
            "position": 0,
            "inputBinding": {
              "separate": false
            }
          },
          {
            "separate": true,
            "position": 1000,
            "valueFrom": {
              "script": "{\n  filename = $job.inputs.input_bam.path\n  \n  /* figuring out output file type */\n  ext = $job.inputs.output_type\n  if (ext === \"BAM\")\n  {\n    out_extension = \"BAM\"\n  }\n  else if (ext === \"SAM\")\n  {\n    out_extension = \"SAM\"\n  }\n  else \n  {\n\tout_extension = filename.split('.').slice(-1)[0].toUpperCase()\n  }  \n  \n  /* if exist moving .bai in bam.bai */\n  if ($job.inputs.create_index === 'True' && $job.inputs.sort_order === 'Coordinate' && out_extension == \"BAM\")\n  {\n    \n    old_name = filename.split('.').slice(0, -1).concat('sorted.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    new_name = filename.split('.').slice(0, -1).concat('sorted.bam.bai').join('.').replace(/^.*[\\\\\\/]/, '')\n    return \"; mv \" + \" \" + old_name + \" \" + new_name\n  }\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:toolkit": "Picard"
      },
      "id": "#Picard_SortSam",
      "sbg:x": 1006.1109076605903,
      "outputs": [
        {
          "id": "#Picard_SortSam.sorted_bam"
        }
      ],
      "inputs": [
        {
          "id": "#Picard_SortSam.validation_stringency",
          "default": "SILENT"
        },
        {
          "id": "#Picard_SortSam.sort_order",
          "default": "Coordinate"
        },
        {
          "id": "#Picard_SortSam.quiet"
        },
        {
          "id": "#Picard_SortSam.output_type",
          "default": "BAM"
        },
        {
          "id": "#Picard_SortSam.memory_per_job"
        },
        {
          "id": "#Picard_SortSam.max_records_in_ram"
        },
        {
          "id": "#Picard_SortSam.input_bam",
          "source": [
            "#HISAT2.out_align"
          ]
        },
        {
          "id": "#Picard_SortSam.create_index",
          "default": "True"
        },
        {
          "id": "#Picard_SortSam.compression_level"
        }
      ]
    },
    {
      "sbg:y": 110.26734924316405,
      "run": {
        "baseCommand": [
          "python",
          "/opt/sbg_fastq_quality_scale_detector.py"
        ],
        "sbg:project": "admin/sbg-public-data",
        "sbg:contributors": [
          "sevenbridges"
        ],
        "x": 344,
        "sbg:categories": [
          "FASTQ-Processing"
        ],
        "temporaryFailCodes": [],
        "label": "SBG FASTQ Quality Detector",
        "outputs": [
          {
            "sbg:fileTypes": "FASTQ",
            "outputBinding": {
              "sbg:metadata": {},
              "glob": "*.fastq"
            },
            "description": "Source FASTQ file with updated metadata.",
            "label": "Result",
            "id": "#result",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "requirements": [],
        "sbg:toolAuthor": "Seven Bridges Genomics",
        "sbg:id": "admin/sbg-public-data/sbg-fastq-quality-detector/7",
        "sbg:latestRevision": 7,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fastq": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "/path/to/fastq.ext"
            }
          }
        },
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/tziotas/sbg_fastq_quality_scale_detector:1.0"
          },
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799955
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799955
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 2,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799957
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 3,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1453799958
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 4,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1467884288
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 5,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1467884288
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 6,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1468402323
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 7,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1468402323
          }
        ],
        "stdin": "",
        "sbg:createdOn": 1453799955,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "required": true,
            "description": "FASTQ file.",
            "label": "Fastq",
            "id": "#fastq",
            "type": [
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--fastq",
              "sbg:cmdInclude": true
            }
          }
        ],
        "y": 110.26734924316405,
        "sbg:sbgMaintained": false,
        "sbg:validationErrors": [],
        "description": "FASTQ Quality Scale Detector detects which quality encoding scheme was used in your reads and automatically enters the proper value in the \"Quality Scale\" metadata field.",
        "stdout": "",
        "sbg:createdBy": "sevenbridges",
        "sbg:modifiedOn": 1468402323,
        "sbg:cmdPreview": "python /opt/sbg_fastq_quality_scale_detector.py --fastq /path/to/fastq.ext /path/to/fastq.ext",
        "sbg:modifiedBy": "sevenbridges",
        "sbg:revision": 7,
        "id": "admin/sbg-public-data/sbg-fastq-quality-detector/7",
        "sbg:license": "Apache License 2.0",
        "arguments": [],
        "sbg:toolkit": "SBGTools"
      },
      "id": "#SBG_FASTQ_Quality_Detector",
      "sbg:x": 344,
      "outputs": [
        {
          "id": "#SBG_FASTQ_Quality_Detector.result"
        }
      ],
      "scatter": "#SBG_FASTQ_Quality_Detector.fastq",
      "inputs": [
        {
          "id": "#SBG_FASTQ_Quality_Detector.fastq",
          "source": [
            "#fastq"
          ]
        }
      ]
    },
    {
      "sbg:y": 506.2963189019098,
      "run": {
        "baseCommand": [
          "python",
          "/opt/hisat2/extract_exons.py"
        ],
        "sbg:project": "admin/sbg-public-data",
        "sbg:contributors": [
          "sevenbridges"
        ],
        "x": 509.9999830457899,
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "temporaryFailCodes": [],
        "sbg:toolkitVersion": "2.0.1",
        "sbg:cmdPreview": "python /opt/hisat2/extract_exons.py  /path/to/Homo_sapiens.GRCh38.83.gtf > Homo_sapiens.GRCh38.83.exon",
        "outputs": [
          {
            "sbg:fileTypes": ".TXT",
            "outputBinding": {
              "glob": "*.exon"
            },
            "description": "Extracted exons in HISAT2 format.",
            "label": "Extracted exons",
            "id": "#output_files",
            "type": [
              "File"
            ]
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "sbg:toolAuthor": "Johns Hopkins University",
        "sbg:id": "admin/sbg-public-data/extract-exons/1",
        "sbg:latestRevision": 1,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "input_GTF": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "/path/to/Homo_sapiens.GRCh38.83.gtf"
            }
          }
        },
        "hints": [
          {
            "value": 1,
            "class": "sbg:CPURequirement"
          },
          {
            "value": 1000,
            "class": "sbg:MemRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/jexnaex/hisat2:2.0.1"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1457546447
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1461762650
          }
        ],
        "sbg:license": "GPLv3 license",
        "id": "admin/sbg-public-data/extract-exons/1",
        "sbg:createdOn": 1457546447,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "required": true,
            "sbg:fileTypes": "GTF",
            "label": "Input GTF file",
            "id": "#input_GTF",
            "sbg:category": "Input files",
            "type": [
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "position": 0,
              "sbg:cmdInclude": true
            }
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:links": [
          {
            "id": "https://ccb.jhu.edu/software/hisat2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/infphilo/hisat2",
            "label": "Github"
          }
        ],
        "sbg:validationErrors": [],
        "description": "__HISAT2 ExtractExons__ extracts a list of exons from a GTF file (in the HISAT2's own format) as follows (three columns).\n   \n   chromosome name `<tab>` zero-offset based left genomic position of an exon `<tab>` zero-offset based right genomic position of an exon",
        "stdout": {
          "script": "name = $job.inputs.input_GTF.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\".exon\"",
          "class": "Expression",
          "engine": "#cwl-js-engine"
        },
        "sbg:createdBy": "sevenbridges",
        "sbg:modifiedOn": 1461762650,
        "label": "HISAT2 ExtractExons",
        "sbg:modifiedBy": "sevenbridges",
        "sbg:revision": 1,
        "stdin": "",
        "y": 506.2963189019098,
        "arguments": [],
        "sbg:toolkit": "HISAT2"
      },
      "id": "#HISAT2_ExtractExons",
      "sbg:x": 509.9999830457899,
      "outputs": [
        {
          "id": "#HISAT2_ExtractExons.output_files"
        }
      ],
      "inputs": [
        {
          "id": "#HISAT2_ExtractExons.input_GTF",
          "source": [
            "#input_GTF"
          ]
        }
      ]
    },
    {
      "sbg:y": 334.0740627712674,
      "run": {
        "baseCommand": [
          "python",
          "/opt/hisat2/extract_splice_sites.py"
        ],
        "sbg:project": "admin/sbg-public-data",
        "sbg:contributors": [
          "sevenbridges"
        ],
        "x": 508.88885498046875,
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "temporaryFailCodes": [],
        "sbg:toolkitVersion": "2.0.1",
        "sbg:cmdPreview": "python /opt/hisat2/extract_splice_sites.py  /bla/bla/Homo_sapiens.GRCh38.83.gtf > Homo_sapiens.GRCh38.83.txt",
        "outputs": [
          {
            "sbg:fileTypes": ".TXT",
            "outputBinding": {
              "glob": "*.txt"
            },
            "description": "Extracted splice sites in HISAT2 format.",
            "label": "Extracted splice sites",
            "id": "#output_files",
            "type": [
              "File"
            ]
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "sbg:toolAuthor": "Johns Hopkins University",
        "sbg:id": "admin/sbg-public-data/extract-splice-sites/2",
        "sbg:latestRevision": 2,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 8000
          },
          "inputs": {
            "input_GTF": {
              "size": 0,
              "secondaryFiles": [],
              "class": "File",
              "path": "/bla/bla/Homo_sapiens.GRCh38.83.gtf"
            }
          }
        },
        "hints": [
          {
            "value": {
              "script": "8000",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "class": "sbg:MemRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/jexnaex/hisat2:2.0.1"
          },
          {
            "value": {
              "script": "1",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1457546447
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1461762650
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 2,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1466173968
          }
        ],
        "sbg:license": "GPLv3 license",
        "id": "admin/sbg-public-data/extract-splice-sites/2",
        "sbg:createdOn": 1457546447,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "required": true,
            "sbg:fileTypes": "GTF",
            "label": "Input GTF file",
            "id": "#input_GTF",
            "sbg:category": "Input",
            "type": [
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true
            }
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:links": [
          {
            "id": "https://ccb.jhu.edu/software/hisat2/index.shtml",
            "label": "Homepage"
          },
          {
            "id": "https://github.com/infphilo/hisat2",
            "label": "Github"
          }
        ],
        "sbg:validationErrors": [],
        "description": "__HISAT2 ExtrsactSpliceSites__ extracts a list of splice sites from a GTF file (in the HISAT2's own format) as follows (four columns).\n   \n   chromosome name `<tab>` zero-offset based genomic position of the flanking base on the left side of an intron `<tab>` zero-offset based genomic position of the flanking base on the right `<tab>` strand",
        "stdout": {
          "script": "name = $job.inputs.input_GTF.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\".txt\"",
          "class": "Expression",
          "engine": "#cwl-js-engine"
        },
        "sbg:createdBy": "sevenbridges",
        "sbg:modifiedOn": 1466173968,
        "label": "HISAT2 ExtractSpliceSites",
        "sbg:modifiedBy": "sevenbridges",
        "sbg:revision": 2,
        "stdin": "",
        "y": 334.0740627712674,
        "arguments": [],
        "sbg:toolkit": "HISAT2"
      },
      "id": "#HISAT2_ExtractSpliceSites",
      "sbg:x": 508.88885498046875,
      "outputs": [
        {
          "id": "#HISAT2_ExtractSpliceSites.output_files"
        }
      ],
      "inputs": [
        {
          "id": "#HISAT2_ExtractSpliceSites.input_GTF",
          "source": [
            "#input_GTF"
          ]
        }
      ]
    },
    {
      "sbg:y": 425.7407379150392,
      "run": {
        "baseCommand": [
          {
            "script": "{\n  \treferences = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"echo No indexing required, tar provided, assuming it is indexed reference.\"\n    \n    }\n  \telse {\n  \t\tcmd = 'mkdir index && /opt/hisat2/hisat2-build'\n  \t}\n    return cmd\n\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:project": "admin/sbg-public-data",
        "sbg:contributors": [
          "sevenbridges",
          "admin"
        ],
        "x": 664.166717529297,
        "sbg:categories": [
          "Indexing",
          "Alignment"
        ],
        "temporaryFailCodes": [],
        "sbg:toolkitVersion": "2.0.1",
        "sbg:cmdPreview": "mkdir index && /opt/hisat2/hisat2-build -p32 /path/to/references-1.fa,/path/to/references-2.ext  index/references-1.references-2_bla_bla1_bla2_HISAT2-2.0.1 && tar -vcf references-1.references-2_bla_bla1_bla2_HISAT2-2.0.1.tar index/",
        "outputs": [
          {
            "sbg:fileTypes": "TAR",
            "outputBinding": {
              "glob": "*HISAT2-2.0.1.tar"
            },
            "description": "Compressed reference and index files.",
            "label": "Index",
            "id": "#tar_out",
            "type": [
              "File"
            ]
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:toolAuthor": "Johns Hopkins University",
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "sbg:id": "admin/sbg-public-data/hisat2-build/3",
        "sbg:latestRevision": 3,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 32,
            "mem": 240000
          },
          "inputs": {
            "references": [
              {
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/path/to/references-1.fa"
              },
              {
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/path/to/references-2.ext"
              }
            ],
            "ftabchars": null,
            "ss": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/bla1.bla"
            },
            "justref": false,
            "offrate": null,
            "nodc": false,
            "dcv": null,
            "large_index": false,
            "snp": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/bla.bla"
            },
            "localoffrate": null,
            "bmaxdivn": null,
            "seed": null,
            "exon": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/bla2.bla"
            },
            "bmax": null,
            "noref": false,
            "localftabchars": null,
            "no_auto": false
          }
        },
        "hints": [
          {
            "value": {
              "script": "{\n\tcmd = 31000\n    var i =0;\n    if ($job.inputs.snp){\n    \ti++\n    }\n  \tif ($job.inputs.ss){\n  \t\ti++\n  \t}\n  \tif ($job.inputs.exon){\n  \t\ti++\n    }\n  \tif ($job.inputs.haplotype){\n  \t\ti++\n  \t}\n  \tif (i > 1) {\n    \tcmd = 240000\n    }\n    return cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "class": "sbg:MemRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/jexnaex/hisat2:2.0.1"
          },
          {
            "value": {
              "script": "{\n\tcmd = 8\n    var i =0;\n    if ($job.inputs.snp){\n    \ti++\n    }\n  \tif ($job.inputs.ss){\n  \t\ti++\n  \t}\n  \tif ($job.inputs.exon){\n  \t\ti++\n    }\n  \tif ($job.inputs.haplotype){\n  \t\ti++\n  \t}\n  \tif (i > 1) {\n    \tcmd = 32\n    }\n    return cmd\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            },
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1457546447
          },
          {
            "sbg:modifiedBy": "sevenbridges",
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1461762650
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revision": 2,
            "sbg:revisionNotes": "Copy of jexnaex/hisat2/hisat2-build/46",
            "sbg:modifiedOn": 1471539431
          },
          {
            "sbg:modifiedBy": "admin",
            "sbg:revision": 3,
            "sbg:revisionNotes": "Copy of jexnaex/hisat2/hisat2-build/48",
            "sbg:modifiedOn": 1471539431
          }
        ],
        "sbg:revisionNotes": "Copy of jexnaex/hisat2/hisat2-build/48",
        "id": "admin/sbg-public-data/hisat2-build/3",
        "sbg:createdOn": 1457546447,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "required": false,
            "sbg:fileTypes": "TXT",
            "description": "Splice site file produced by HISAT2 Extract Splice Sites.",
            "label": "Splice sites file",
            "id": "#ss",
            "sbg:category": "Input files",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd = \"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.ss != undefined)\n        cmd = \"--ss \" + $job.inputs.ss.path\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "required": false,
            "sbg:fileTypes": "SNP",
            "description": "SNP file produced by HISAT2 Extract SNPs-Haplotypes UCSC/VCF.",
            "label": "SNP file",
            "id": "#snp",
            "sbg:category": "Input files",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n    cmd =\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.snp != undefined)\n        cmd = \"--snp \" + $job.inputs.snp.path\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Seed for rundom number generator.",
            "label": "Seed",
            "id": "#seed",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd=\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.seed)\n        cmd = \"--seed \" + $job.inputs.seed\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "required": true,
            "sbg:fileTypes": "FA, FASTA, FA.GZ, FASTA.GZ",
            "description": "List of files with ref sequences",
            "sbg:stageInput": "link",
            "id": "#references",
            "sbg:category": "Input files",
            "label": "References",
            "type": [
              {
                "items": "File",
                "type": "array",
                "name": "references"
              }
            ],
            "inputBinding": {
              "separate": false,
              "position": 1,
              "itemSeparator": " ",
              "valueFrom": {
                "script": "{\n    references = [].concat($job.inputs.references)\n    var cmd = \"\"\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        for (var i=0;i < references.length-1;i++){\n         cmd = cmd.concat(references[i].path+\",\")\n        \n        }\n        cmd = cmd.concat(references[references.length-1].path)\n      }\n  \treturn cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "SA is sampled every 2^offRate BWT chars (default: 5).",
            "sbg:altPrefix": "-o",
            "label": "Sampling rate",
            "sbg:toolDefaultValue": "5",
            "id": "#offrate",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd=\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.offrate)\n        cmd = \"--offrate \" + $job.inputs.offrate\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Don't build .3/.4.bt2 (packed reference) portion.",
            "sbg:altPrefix": "-r",
            "label": "Disable building packed reference",
            "sbg:toolDefaultValue": "false",
            "id": "#noref",
            "sbg:category": "Options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\t\n  \tcmd =\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.noref)\n        cmd = \"--noref\"\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Disable diff-cover (algorithm becomes quadratic)",
            "label": "No diff-cover",
            "sbg:toolDefaultValue": "false",
            "id": "#nodc",
            "sbg:category": "Options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\t\n  \tcmd =\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.nodc) \n        cmd = \"--nodc\"\n      }\n \treturn cmd     \n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Disable automatic -p/--bmax/--dcv memory-fitting",
            "sbg:altPrefix": "-a",
            "label": "Disable automatic memory fitting",
            "sbg:toolDefaultValue": "false",
            "id": "#no_auto",
            "sbg:category": "Options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n    cmd =\"\"\n\treferences = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"\"\n    \n    }\n    else {\n      if ($job.inputs.noauto)\n      cmd = \"--noauto\"\n    }\n\treturn cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "SA (local) is sampled every 2^offRate BWT chars (default: 3).",
            "label": "Local sample rate",
            "sbg:toolDefaultValue": "3",
            "id": "#localoffrate",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd = \"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.localoffrate)\n        cmd = \"--localoffrate \" + $job.inputs.localoffrate\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "# of chars consumed in initial lookup in a local index (default: 6).",
            "label": "Number of chars in lookup (local)",
            "sbg:toolDefaultValue": "6",
            "id": "#localftabchars",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\t\n  \tcmd = \"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.localftabchars)\n        cmd = \"--localftabchars \" + $job.inputs.localftabchars\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Force generated index to be 'large', even if ref has fewer than 4 billion nucleotides.",
            "label": "Force large index",
            "sbg:toolDefaultValue": "false",
            "id": "#large_index",
            "sbg:category": "Options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n    cmd =\"\"\n\treferences = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"\"\n    \n    }\n    else {\n      if ($job.inputs.largeindex)\n      cmd = \"--large-index\"\n    }\n\treturn cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Just build .3/.4.bt2 (packed reference) portion.",
            "label": "Build only packed portion",
            "sbg:toolDefaultValue": "false",
            "id": "#justref",
            "sbg:category": "Options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\t\n  \tcmd=\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.justref)\n        cmd = \"--justref\"\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "# of chars consumed in initial lookup (default: 10).",
            "sbg:altPrefix": "-t",
            "label": "Number of chars in lookup",
            "sbg:toolDefaultValue": "10",
            "id": "#ftabchars",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd=\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.ftabchars)\n        cmd = \"--ftabchars \" + $job.inputs.ftabchars\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "required": false,
            "sbg:fileTypes": "TXT",
            "description": "Exon file produced by HISAT2 Extract Exons.",
            "label": "Exon file",
            "id": "#exon",
            "sbg:category": "Input files",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n    cmd = \"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.exon != undefined)\n        cmd = \"--exon \" + $job.inputs.exon.path\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Diff-cover period for blockwise (default: 1024).",
            "label": "Diff-cover period",
            "sbg:toolDefaultValue": "1024",
            "id": "#dcv",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\n  \tcmd=\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.dcv)\n        cmd = \"--dcv \" + $job.inputs.dcv\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Max bucket size as divisor of reference length (default: 4).",
            "label": "Max bucket size (as divisior)",
            "sbg:toolDefaultValue": "4",
            "id": "#bmaxdivn",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{\t\n  \tcmd =\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if($job.inputs.bmaxdivn)\n        cmd = \"--bmaxdivn \" + $job.inputs.bmaxdivn\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Max bucket size for blockwise suffix-array builder.",
            "label": "Max bucket size",
            "id": "#bmax",
            "sbg:category": "Options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": false,
              "valueFrom": {
                "script": "{   \n  \tcmd =\"\"\n    references = [].concat($job.inputs.references)\n    ext = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n      if (ext === 'tar'){\n          cmd = \"\"\n\n      }\n      else {\n        if ($job.inputs.bmax)\n        cmd = \"--bmax \" + $job.inputs.bmax\n      }\n      return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          }
        ],
        "sbg:license": "GPLv3 license",
        "sbg:links": [
          {
            "id": "https://ccb.jhu.edu/software/hisat2/manual.shtml#the-hisat2-build-indexer",
            "label": "Homepage"
          },
          {
            "id": "ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/downloads/hisat2-2.0.4-source.zip",
            "label": "Source code"
          },
          {
            "id": "https://wiki.rc.ufl.edu/doc/HISAT2",
            "label": "Wiki"
          },
          {
            "id": "ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/downloads/hisat2-2.0.4-source.zip",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/vaop/ncurrent/full/nmeth.3317.html",
            "label": "Publications"
          }
        ],
        "sbg:validationErrors": [],
        "description": "__HISAT2 Build__ builds a HISAT2 index from a set of DNA sequences. hisat2-build outputs a set of 8 files with suffixes .1.ht2, .2.ht2, .3.ht2, .4.ht2, .5.ht2, .6.ht2, .7.ht2, and .8.ht2. In the case of a large index these suffixes will have a ht2l termination. These files together constitute the index: they are all that is needed to align reads to that reference. The original sequence FASTA files are no longer used by HISAT2 once the index is built.\n\nUse of Karkkainen's blockwise algorithm allows hisat2-build to trade off between running time and memory usage. hisat2-build has three options governing how it makes this trade: [-p/--packed], --bmax/--bmaxdivn, and --dcv. By default, hisat2-build will automatically search for the settings that yield the best running time without exhausting memory. This behavior can be disabled using the -a/--noauto option.\n\nThe indexer provides options pertaining to the \"shape\" of the index, e.g. --offrate governs the fraction of Burrows-Wheeler rows that are \"marked\" (i.e., the density of the suffix-array sample; see the original FM Index paper for details). All of these options are potentially profitable trade-offs depending on the application. They have been set to defaults that are reasonable for most cases according to our experiments. See Performance tuning for details.\n\nhisat2-build can generate either small or large indexes. The wrapper will decide which based on the length of the input genome. If the reference does not exceed 4 billion characters but a large index is preferred, the user can specify --large-index to force hisat2-build to build a large index instead.\n\nThe HISAT2 index is based on the FM Index of Ferragina and Manzini, which in turn is based on the Burrows-Wheeler transform. The algorithm used to build the index is based on the blockwise algorithm of Karkkainen.",
        "stdout": "",
        "sbg:createdBy": "sevenbridges",
        "sbg:modifiedOn": 1471539431,
        "label": "HISAT2 Build",
        "sbg:modifiedBy": "admin",
        "sbg:revision": 3,
        "stdin": "",
        "y": 425.7407379150392,
        "arguments": [
          {
            "separate": false,
            "prefix": "-p",
            "valueFrom": {
              "script": "{\n    references = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"\"\n    \n    }\n  \telse {\n    \tcmd = $job.allocatedResources.cpu\n    }\n\treturn cmd\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "position": 2,
            "valueFrom": {
              "script": "{\n  references = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"\"\n    \n    }\n    else {\n      references = [].concat($job.inputs.references)\n      var base = \"\"\n      ref_path = \"\"\n      for (var i =0; i < references.length-1; i++){\n        var ext = references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n        if (ext === 'bz2' || ext === 'gz') {\n          base = base.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\".\")\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\"* \")\n        }\n        else {\n          base = base.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\".\")\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\"* \")\n        }\n      }\n      ext = references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n        if (ext === 'bz2' || ext === 'gz') {\n          base = base.concat(references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\"))\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\"* \")\n        }\n        else {\n          base = base.concat(references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\"))\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\"* \")\n        }\n      var snp = \"\"\n      if ($job.inputs.snp){\n        snp = \"_\" + $job.inputs.snp.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      var ss = \"\"\n      if ($job.inputs.ss){\n      \tss = \"_\" + $job.inputs.ss.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      var exon = \"\"\n      if ($job.inputs.exon){\n      \texon = \"_\" + $job.inputs.exon.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      base = base + snp + ss + exon\n      cmd =\"index/\" + base + \"_HISAT2-2.0.1\"\n    }\n  return cmd\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": false,
            "position": 3,
            "valueFrom": {
              "script": "{\n  references = [].concat($job.inputs.references)\n\text = references[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext === 'tar'){\n    \tcmd = \"\"\n    \n    }\n    else {\n      references = [].concat($job.inputs.references)\n      var base = \"\"\n      ref_path = \"\"\n      for (var i =0; i < references.length-1; i++){\n        var ext = references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n        if (ext === 'bz2' || ext === 'gz') {\n          base = base.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\".\")\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\"* \")\n        }\n        else {\n          base = base.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\".\")\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\"* \")\n        }\n      }\n      ext = references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n        if (ext === 'bz2' || ext === 'gz') {\n          base = base.concat(references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\"))\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-2).join(\".\")+\"* \")\n        }\n        else {\n          base = base.concat(references[references.length-1].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\"))\n          ref_path = ref_path.concat(references[i].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\"* \")\n        }\n      var snp = \"\"\n      if ($job.inputs.snp){\n        snp = \"_\" + $job.inputs.snp.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      var ss = \"\"\n      if ($job.inputs.ss){\n      \tss = \"_\" + $job.inputs.ss.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      var exon = \"\"\n      if ($job.inputs.exon){\n      \texon = \"_\" + $job.inputs.exon.path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")\n      }\n      base = base + snp + ss + exon\n      cmd =\"&& tar -vcf \" + base + \"_HISAT2-2.0.1.tar index/\"\n    }\n  return cmd\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:toolkit": "HISAT2"
      },
      "id": "#HISAT2_Build_1",
      "sbg:x": 664.166717529297,
      "outputs": [
        {
          "id": "#HISAT2_Build_1.tar_out"
        }
      ],
      "inputs": [
        {
          "id": "#HISAT2_Build_1.ss",
          "source": [
            "#HISAT2_ExtractSpliceSites.output_files"
          ]
        },
        {
          "id": "#HISAT2_Build_1.snp"
        },
        {
          "id": "#HISAT2_Build_1.seed"
        },
        {
          "id": "#HISAT2_Build_1.references",
          "source": [
            "#reference_files"
          ]
        },
        {
          "id": "#HISAT2_Build_1.offrate"
        },
        {
          "id": "#HISAT2_Build_1.noref"
        },
        {
          "id": "#HISAT2_Build_1.nodc"
        },
        {
          "id": "#HISAT2_Build_1.no_auto"
        },
        {
          "id": "#HISAT2_Build_1.localoffrate"
        },
        {
          "id": "#HISAT2_Build_1.localftabchars"
        },
        {
          "id": "#HISAT2_Build_1.large_index"
        },
        {
          "id": "#HISAT2_Build_1.justref"
        },
        {
          "id": "#HISAT2_Build_1.ftabchars"
        },
        {
          "id": "#HISAT2_Build_1.exon",
          "source": [
            "#HISAT2_ExtractExons.output_files"
          ]
        },
        {
          "id": "#HISAT2_Build_1.dcv"
        },
        {
          "id": "#HISAT2_Build_1.bmaxdivn"
        },
        {
          "id": "#HISAT2_Build_1.bmax"
        }
      ]
    },
    {
      "sbg:y": 176.77083969116214,
      "run": {
        "baseCommand": [
          {
            "script": "{\n\treturn \"tar -xf \" + $job.inputs.indexed_reference.path + \" && /opt/hisat2/hisat2\"\n}",
            "class": "Expression",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:project": "marko_zecevic/sbde1",
        "sbg:contributors": [
          "marko_zecevic"
        ],
        "sbg:categories": [
          "Indexing",
          "Alignment"
        ],
        "temporaryFailCodes": [],
        "sbg:toolkitVersion": "2.0.1",
        "sbg:cmdPreview": "tar -xf /path/to/hg38.tar && /opt/hisat2/hisat2  -f -p 8 -x index/hg38 -1 /path/to/reads-1.fa -2 /path/to/reads-2.fa -S reads-1.HISAT-2.0.1.aligned.sam",
        "outputs": [
          {
            "sbg:fileTypes": "SAM",
            "outputBinding": {
              "glob": "*aligned.sam"
            },
            "description": "Alignment SAM file.",
            "label": "Output alignment",
            "id": "#out_align",
            "type": [
              "File"
            ]
          },
          {
            "sbg:fileTypes": "TXT",
            "outputBinding": {
              "glob": "novel_splice_sites.txt"
            },
            "description": "HISAT2 reports a list of splice sites in the file : chromosome name `` genomic position of the flanking base on the left side of an intron `` genomic position of the flanking base on the right `` strand",
            "label": "Novel splice sites",
            "id": "#novel_ss_out",
            "type": [
              "null",
              "File"
            ]
          },
          {
            "sbg:fileTypes": "TXT",
            "outputBinding": {
              "glob": "metrics.txt"
            },
            "description": "HISAT2 alignment metrics",
            "label": "Metrics file",
            "id": "#metrics_file",
            "type": [
              "null",
              "File"
            ]
          }
        ],
        "requirements": [
          {
            "id": "#cwl-js-engine",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ]
          }
        ],
        "sbg:toolAuthor": "Johns Hopkins University",
        "sbg:id": "marko_zecevic/sbde1/hisat2/1",
        "sbg:latestRevision": 1,
        "successCodes": [],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 8,
            "mem": 31000
          },
          "inputs": {
            "no_overlap": false,
            "no_discordant": false,
            "seed": false,
            "solexa_quals": false,
            "dovetail": false,
            "met_file": false,
            "rfg": {
              "fields": {
                "rfg_open": null,
                "rfg_extend": null
              }
            },
            "intquals": false,
            "novel_ss": true,
            "reorder": false,
            "pen_canintronlen": "",
            "distinct_align": 10,
            "omit_sec_seq": false,
            "norc": false,
            "rg": null,
            "min_intronlen": null,
            "upto": null,
            "rg_id": "",
            "pen_noncansplice": null,
            "no_contain": false,
            "qc_filter": false,
            "no_hd": false,
            "maxins": null,
            "mp": {
              "fields": {
                "mp_max": null,
                "mp_min": null
              }
            },
            "reads": [
              {
                "metadata": {
                  "paired_end": "1"
                },
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/path/to/reads-1.fa"
              },
              {
                "metadata": {
                  "paired_end": "2"
                },
                "size": 0,
                "class": "File",
                "secondaryFiles": [],
                "path": "/path/to/reads-2.fa"
              }
            ],
            "dta_cufflinks": false,
            "downstream_assembly": false,
            "ignore_quals": false,
            "trim5": null,
            "skip": null,
            "qseq": false,
            "pen_cansplice": null,
            "minins": null,
            "transcriptome_only": false,
            "score_min": "",
            "nofw": false,
            "np": 3,
            "trim3": null,
            "mate_orientations": "Forward-reverse",
            "indexed_reference": {
              "size": 0,
              "class": "File",
              "secondaryFiles": [],
              "path": "/path/to/hg38.tar"
            },
            "no_spliced_alignment": false,
            "sp": {
              "fields": {
                "sp_max": null,
                "sp_min": null
              }
            },
            "pen_noncanintronlen": "",
            "no_unal": false,
            "n_ceil": "",
            "non_deterministic": false,
            "phred64": false,
            "raw": false,
            "rna_strandness": "F",
            "no_temp_splicesite": false,
            "rdg": {
              "fields": {
                "rdg_extend": null,
                "rdg_open": null
              }
            },
            "end_to_end": false,
            "max_intronlen": null,
            "no_mixed": false,
            "no_sq": false
          }
        },
        "hints": [
          {
            "value": 31000,
            "class": "sbg:MemRequirement"
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/jexnaex/hisat2:2.0.1"
          },
          {
            "value": 8,
            "class": "sbg:CPURequirement"
          }
        ],
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedBy": "marko_zecevic",
            "sbg:revision": 0,
            "sbg:revisionNotes": "Copy of admin/sbg-public-data/hisat2/6",
            "sbg:modifiedOn": 1472049633
          },
          {
            "sbg:modifiedBy": "marko_zecevic",
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedOn": 1472054931
          }
        ],
        "id": "https://api.sbgenomics.com/v2/apps/marko_zecevic/sbde1/hisat2/1/raw/",
        "sbg:createdOn": 1472049633,
        "sbg:image_url": null,
        "class": "CommandLineTool",
        "inputs": [
          {
            "sbg:fileTypes": "BZ2, GZ, FQ, FASTQ, FASTA, FA, MFA",
            "description": "Paired or unpaired reads, __for paired reads paired_end metadata field has to be set for 1/2. Paired only or unpaired only reads can be set in one run. If reads are paired corresponding mate1s and mate2s have to be completely matched.__",
            "label": "Reads",
            "id": "#reads",
            "sbg:category": "Input files",
            "type": [
              {
                "items": "File",
                "type": "array",
                "name": "reads"
              }
            ],
            "inputBinding": {
              "separate": false,
              "position": 2,
              "itemSeparator": " ",
              "valueFrom": {
                "script": "{\n  cmd = \"\"\n  reads = [].concat($job.inputs.reads)\n  reads1 = [];\n  reads2 = [];\n  u_reads = [];\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n  if (reads1.length > 0 & reads1.length == reads2.length){\n      cmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n  }\n  if (u_reads.length > 0){\n      cmd = \" -U \" + u_reads.join(\",\");\n  }\n  return cmd\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:fileTypes": "TAR",
            "description": "TAR containing index files as providid by HISAT2 Build 2.0.4.",
            "label": "Indexed reference",
            "id": "#indexed_reference",
            "sbg:category": "Input files",
            "type": [
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "-x",
              "position": 1,
              "valueFrom": {
                "script": "{\n    var a = '22_20-21M_snp144Common_HISAT2-2.0.1.tar'\n    \n    var ref = $job.inputs.indexed_reference.path.split(\"/\").slice(-1)[0].split(\"_\")\n    if (ref[0] == \"\"){\n      ref = ref.slice(2,ref.length).join(\".\").split(\".\").slice(0,-1).join(\".\")\n    \t\n    }\n  \telse {\n      ref = ref.join(\"_\").split(\".\").slice(0,-1).join(\".\")\t\n    }\n\treturn \"index/\" + ref\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Query input files are in Illumina's qseq format.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#qseq",
            "sbg:category": "Input options",
            "label": "Qseq reads",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "label": "Raw sequences",
            "sbg:toolDefaultValue": "false",
            "id": "#raw",
            "sbg:category": "Input options",
            "description": "Query input files are raw one-sequence-per-line."
          },
          {
            "description": "Skip the first <int> reads/pairs in the input",
            "label": "Skip first <n> reads",
            "sbg:toolDefaultValue": "0",
            "id": "#skip",
            "sbg:category": "Input options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--skip",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Stop after first <int> reads/pairs",
            "sbg:altPrefix": "-u",
            "label": "Align first <n> reads",
            "sbg:toolDefaultValue": "no limit",
            "id": "#upto",
            "sbg:category": "Input options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--upto",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Trim <int> bases from 5'/left end of reads.",
            "sbg:altPrefix": "-5",
            "label": "Trim 5'",
            "sbg:toolDefaultValue": "0",
            "id": "#trim5",
            "sbg:category": "Input options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--trim5",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Trim <int> bases from 3'/right end of reads.",
            "sbg:altPrefix": "-3",
            "label": "Trim 3'",
            "sbg:toolDefaultValue": "0",
            "id": "#trim3",
            "sbg:category": "Input options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--trim3",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Qualities are Phred+64.",
            "label": "Phred 64 quality scale",
            "sbg:toolDefaultValue": "false",
            "id": "#phred64",
            "sbg:category": "Input options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": false,
              "position": 0,
              "valueFrom": {
                "script": "{\n\tcmd=\"\"\n    reads = [].concat($job.inputs.reads)\n    if ($job.inputs.phred64 | reads[0].metadata.quality_scale == 'illumina13'){\n    \tcmd=\"--phred64\"\n    }\n  \tif ($job.inputs.intquals){\n  \t\tcmd =\"--int-quals\"\n  \t}\n\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Qualities encoded as space-delimited integers",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#intquals",
            "sbg:category": "Input options",
            "label": "Ingteger qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "description": "Convert input qualities from [Solexa][Phred quality] (which can be negative) to [Phred][Phred quality] (which can't). This scheme was used in older Illumina GA Pipeline versions (prior to 1.3).",
            "label": "Solexa quals",
            "sbg:toolDefaultValue": "false",
            "id": "#solexa_quals",
            "sbg:category": "Input options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets a function governing the maximum number of ambiguous characters (usually `N`s and/or `.`s) allowed in a read as a function of read length. For instance, specifying `-L,0,0.15` sets the N-ceiling function `f` to `f(x) = 0 + 0.15 * x`, where x is the read length. See also: [setting function options]. Reads exceeding this ceiling are [filtered out].",
            "label": "N ceil",
            "sbg:toolDefaultValue": "L,0,0.15",
            "id": "#n_ceil",
            "sbg:category": "Alignment options",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--n-ceil",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. input is treated as though all quality values are high. This is also the default behavior when the input doesn't specify quality values.",
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "false",
            "id": "#ignore_quals",
            "sbg:category": "Alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--ignore-quals",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "If `--nofw` is specified, `hisat2` will not attempt to align unpaired reads to the forward (Watson) reference strand.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#nofw",
            "sbg:category": "Alignment options",
            "label": "No forward",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--nofw",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "If `--norc` is specified, `hisat2` will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, `--norc` pertain to the fragments.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#norc",
            "sbg:category": "Alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--norc",
              "sbg:cmdInclude": true
            }
          },
          {
            "id": "#mp",
            "sbg:category": "Scoring options",
            "description": "Sets the maximum (`MX`) and minimum (`MN`) mismatch penalties, both integers. A number less than or equal to `MX` and greater than or equal to `MN` is subtracted from the alignment score for each position where a read character aligns to a reference character, the characters do not match, and neither is an `N`. If [`--ignore-quals`] is specified, the number subtracted quals `MX`. Otherwise, the number subtracted is `MN + floor( (MX-MN)(MIN(Q, 40.0)/40.0) )` where Q is the Phred quality value. Default: `MX` = 6, `MN` = 2.",
            "type": [
              "null",
              {
                "fields": [
                  {
                    "sbg:toolDefaultValue": "2",
                    "name": "mp_min",
                    "label": "MIN",
                    "type": [
                      "null",
                      "int"
                    ],
                    "inputBinding": {
                      "separate": true,
                      "prefix": "--mp",
                      "valueFrom": {
                        "script": "{\n\treturn $job.inputs.mp.mp_max + \",\" + $job.inputs.mp.mp_min\n}",
                        "class": "Expression",
                        "engine": "#cwl-js-engine"
                      },
                      "sbg:cmdInclude": "true"
                    }
                  },
                  {
                    "sbg:toolDefaultValue": "6",
                    "name": "mp_max",
                    "type": [
                      "null",
                      "int"
                    ],
                    "label": "MAX"
                  }
                ],
                "type": "record",
                "name": "mp"
              }
            ],
            "label": "Missmatch penalties"
          },
          {
            "id": "#sp",
            "sbg:category": "Scoring options",
            "description": "Sets the maximum (`MX`) and minimum (`MN`) penalties for soft-clipping per base, both integers. A number less than or equal to `MX` and greater than or equal to `MN` is subtracted from the alignment score for each position. The number subtracted is `MN + floor( (MX-MN)(MIN(Q, 40.0)/40.0) )` where Q is the Phred quality value. Default: `MX` = 2, `MN` = 1.",
            "type": [
              "null",
              {
                "fields": [
                  {
                    "label": "MIN",
                    "sbg:toolDefaultValue": "1",
                    "name": "sp_min",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "inputBinding": {
                      "separate": true,
                      "prefix": "--sp",
                      "valueFrom": {
                        "script": "{\n\treturn $job.inputs.sp.sp_max + \",\" + $job.inputs.sp.sp_min\n}",
                        "class": "Expression",
                        "engine": "#cwl-js-engine"
                      },
                      "sbg:cmdInclude": "true"
                    }
                  },
                  {
                    "sbg:toolDefaultValue": "2",
                    "name": "sp_max",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "label": "MAX"
                  }
                ],
                "type": "record",
                "name": "sp"
              }
            ],
            "label": "Soft-clipping penalties"
          },
          {
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as `N`. Default: 1.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "1",
            "id": "#np",
            "sbg:category": "Scoring options",
            "label": "'N' penalty",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--np",
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:stageInput": null,
            "description": "Sets the read gap open (``) and extend (``) penalties. A read gap of length N gets a penalty of `` + N * ``.",
            "label": "Gap penalty",
            "id": "#rdg",
            "sbg:category": "Scoring options",
            "type": [
              "null",
              {
                "fields": [
                  {
                    "label": "Gap open penalty",
                    "sbg:toolDefaultValue": "5",
                    "name": "rdg_open",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "inputBinding": {
                      "separate": true,
                      "prefix": "--rdg",
                      "valueFrom": {
                        "script": "{\n\treturn $job.inputs.rdg.rdg_open + \",\" + $job.inputs.rdg.rdg_extend\n}",
                        "class": "Expression",
                        "engine": "#cwl-js-engine"
                      },
                      "sbg:cmdInclude": "true"
                    }
                  },
                  {
                    "sbg:toolDefaultValue": "3",
                    "name": "rdg_extend",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "label": "Gap extend penalty"
                  }
                ],
                "type": "record",
                "name": "rdg"
              }
            ]
          },
          {
            "id": "#rfg",
            "sbg:category": "Scoring options",
            "description": "Sets the reference gap open (``) and extend (``) penalties. A reference gap of length N gets a penalty of `` + N * ``. Default: 5, 3",
            "type": [
              "null",
              {
                "fields": [
                  {
                    "label": "Open penalty",
                    "sbg:toolDefaultValue": "5",
                    "name": "rfg_open",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "inputBinding": {
                      "separate": true,
                      "prefix": "--rfg",
                      "valueFrom": {
                        "script": "{\n  return $job.inputs.rfg.rfg_open + \",\" + $job.inputs.rfg.rfg_extend\n}",
                        "class": "Expression",
                        "engine": "#cwl-js-engine"
                      },
                      "sbg:cmdInclude": "true"
                    }
                  },
                  {
                    "sbg:toolDefaultValue": "3",
                    "name": "rfg_extend",
                    "sbg:stageInput": null,
                    "type": [
                      "null",
                      "int"
                    ],
                    "label": "Extend penalty"
                  }
                ],
                "type": "record",
                "name": "rfg"
              }
            ],
            "label": "Reference gap penalties"
          },
          {
            "description": "Sets a function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. For instance, specifying `L,0,-0.6` sets the minimum-score function `f` to `f(x) = 0 + -0.6 * x`, where `x` is the read length. See also: [setting function options].",
            "label": "Minimum alignment score",
            "sbg:toolDefaultValue": "L,0,-0.2",
            "id": "#score_min",
            "sbg:category": "Scoring options",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--score-min",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets the penalty for each pair of canonical splice sites (e.g. GT/AG).",
            "label": "Canonical splice site penalty",
            "sbg:toolDefaultValue": "0",
            "id": "#pen_cansplice",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--pen-cansplice",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets the penalty for each pair of non-canonical splice sites (e.g. non-GT/AG).",
            "label": "Non canonical splice site penalty",
            "sbg:toolDefaultValue": "12",
            "id": "#pen_noncansplice",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--pen-noncansplice",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets the penalty for long introns with canonical splice sites so that alignments with shorter introns are preferred to those with longer ones. Default: G,-8,1",
            "label": "Long introns w/ canonical splice site penalty",
            "sbg:toolDefaultValue": "G,-8,1",
            "id": "#pen_canintronlen",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--pen-canintronlen",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets the penalty for long introns with noncanonical splice sites so that alignments with shorter introns are preferred to those with longer ones. Default: G,-8,1",
            "label": "Long introns w/ noncanonical splice sites penalty",
            "sbg:toolDefaultValue": "G,-8,1",
            "id": "#pen_noncanintronlen",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--pen-noncanintronlen",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets minimum intron length. Default: 20",
            "label": "Minimum intron length",
            "sbg:toolDefaultValue": "20",
            "id": "#min_intronlen",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--min-intronlen",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Sets maximum intron length. Default: 500000",
            "label": "Maximum intron length",
            "sbg:toolDefaultValue": "500000",
            "id": "#max_intronlen",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--max-intronlen",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:fileTypes": "TXT",
            "description": "With this mode, you can provide a list of known splice sites, which HISAT2 makes use of to align reads with small anchors. You can create such a list using `HISAT2 Extract Splice Sites genes.gtf > splicesites.txt`, where  `genes.gtf` is a gene annotation file, and `splicesites.txt` is a list of splice sites with which you provide HISAT2 in this mode. Note that it is better to use indexes built using annotated transcripts (such asgenome_tran or genome_snp_tran), which works better than using this option. It has no effect to provide splice sites that are already included in the indexes.",
            "label": "Know splice sites",
            "id": "#known_ss",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--known-splicesite-infile",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "In this mode, HISAT2 reports a list of splice sites in the file : chromosome name `` genomic position of the flanking base on the left side of an intron `` genomic position of the flanking base on the right `` strand.",
            "label": "Novel splice sites out",
            "sbg:toolDefaultValue": "false",
            "id": "#novel_ss",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--novel-splicesite-outfile",
              "valueFrom": {
                "script": "{\n\treturn \"novel_splice_sites.txt\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:fileTypes": "TXT",
            "description": "With this mode, you can provide a list of novel splice sites that were generated from the option \"--novel-splicesite-outfile\".",
            "label": "Novel splice sites",
            "id": "#novel_ss_in",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "File"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--novel-splicesite-infile",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "HISAT2, by default, makes use of splice sites found by earlier reads to align later reads in the same run, in particular, reads with small anchors (<= 15 bp). The option disables this default alignment strategy.",
            "label": "No temp splice sites",
            "sbg:toolDefaultValue": "false",
            "id": "#no_temp_splicesite",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-temp-splicesite",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Disable spliced alignment.",
            "label": "No spliced alignment",
            "sbg:toolDefaultValue": "false",
            "id": "#no_spliced_alignment",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-spliced-alignment",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Specify strand-specific information: the default is unstranded. For single-end reads, use F or R. 'F' means a read corresponds to a transcript. 'R' means a read corresponds to the reverse complemented counterpart of a transcript. For paired-end reads, use either FR or RF. With this option being used, every read alignment will have an XS attribute tag: '+' means a read belongs to a transcript on '+' strand of genome. '-' means a read belongs to a transcript on '-' strand of genome. (TopHat has a similar option, --library-type option, where fr-firststrand corresponds to R and RF; fr-secondstrand corresponds to F and FR.)",
            "label": "RNA strandedness",
            "id": "#rna_strandness",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              {
                "symbols": [
                  "F",
                  "R",
                  "FR",
                  "RF"
                ],
                "type": "enum",
                "name": "rna_strandness"
              }
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--rna-strandness",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:stageInput": null,
            "description": "Report only those alignments within known transcripts.",
            "sbg:altPrefix": "--transcriptome-mapping-only",
            "label": "Align only to transcriptome",
            "sbg:toolDefaultValue": "false",
            "id": "#transcriptome_only",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--tmo",
              "sbg:cmdInclude": true
            }
          },
          {
            "sbg:stageInput": null,
            "description": "Report alignments tailored for transcript assemblers including StringTie. With this option, HISAT2 requires longer anchor lengths for de novo discovery of splice sites. This leads to fewer alignments with short-anchors, which helps transcript assemblers improve significantly in computationa and memory usage.",
            "sbg:altPrefix": "--downstream-transcriptome-assembly",
            "label": "Alignments for transcriptome assembly",
            "sbg:toolDefaultValue": "false",
            "id": "#downstream_assembly",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--dta",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Report alignments tailored specifically for Cufflinks. In addition to what HISAT2 does with the above option (--dta), With this option, HISAT2 looks for novel splice sites with three signals (GT/AG, GC/AG, AT/AC), but all user-provided splice sites are used irrespective of their signals. HISAT2 produces an optional field, XS:A:[+-], for every spliced alignment.",
            "label": "Alignment tailored for cufflinks",
            "sbg:toolDefaultValue": "false",
            "id": "#dta_cufflinks",
            "sbg:category": "Spliced alignment options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--dta-cufflinks",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "It searches for at most `` distinct, primary alignments for each read. Primary alignments mean alignments whose alignment score is equal or higher than any other alignments. The search terminates when it can't find more distinct valid alignments, or when it finds ``, whichever happens first. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than `` distinct, valid alignments, `hisat2` does not gaurantee that the `` alignments reported are the best possible in terms of alignment score. Default: 5 (HFM) or 10 (HGFM) Note: HISAT2 is not designed with large values for `-k` in mind, and when aligning reads to long, repetitive genomes large `-k` can be very, very slow.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "5(HFM)/10(HGFM)",
            "id": "#distinct_align",
            "sbg:category": "Spliced alignment options",
            "label": "Max distinct alignments",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "-k",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if `-I 60` is specified and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as [`-X`] is also satisfied). A 19-bp gap would not be valid in that case. If trimming options [`-3`] or [`-5`] are also used, the [`-I`] constraint is applied with respect to the untrimmed mates. The larger the difference between [`-I`] and [`-X`], the slower HISAT2 will run. This is because larger differences bewteen [`-I`] and [`-X`] require that HISAT2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), HISAT2 is very efficient. Default: 0 (essentially imposing no minimum)",
            "sbg:altPrefix": "-I",
            "label": "Min fragment length",
            "sbg:toolDefaultValue": "0",
            "id": "#minins",
            "sbg:category": "Paired-end options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--minins",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if `-X 100` is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as [`-I`] is also satisfied). A 61-bp gap would not be valid in that case. If trimming options [`-3`] or [`-5`] are also used, the `-X` constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between [`-I`] and [`-X`], the slower HISAT2 will run. This is because larger differences bewteen [`-I`] and [`-X`] require that HISAT2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), HISAT2 is very efficient. Default: 500.",
            "sbg:altPrefix": "-X",
            "label": "Maximum fragment length",
            "sbg:toolDefaultValue": "500",
            "id": "#maxins",
            "sbg:category": "Paired-end options",
            "type": [
              "null",
              "int"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--maxins",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if `--fr` is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints ([`-I`] and [`-X`]) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. `--rf` likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. ` --ff` requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default: `--fr` (appropriate for Illumina's Paired-end Sequencing Assay).",
            "label": "Mate orientations",
            "sbg:toolDefaultValue": "Forward-reverse",
            "id": "#mate_orientations",
            "sbg:category": "Paired-end options",
            "type": [
              "null",
              {
                "symbols": [
                  "Forward-reverse",
                  "Reverse-forward",
                  "Forward-forward"
                ],
                "type": "enum",
                "name": "mate_orientations"
              }
            ],
            "inputBinding": {
              "separate": true,
              "valueFrom": {
                "script": "{\n\tcmd=\"\"\n    if ($job.inputs.mate_orientations == 'Forward-reverse'){\n    \tcmd=\"--fr\"\n    }\n  \telse if ($job.inputs.mate_orientations == 'Forward-forward'){\n  \t\tcmd=\"--ff\"\n  \t}\n  \telse if ($job.inputs.mate_orientations == 'Refeverse-forward'){\n  \t\tcmd=\"--rf\"\n  \t}\n\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "By default, when `hisat2` cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "label": "No individual alignment",
            "sbg:toolDefaultValue": "false",
            "id": "#no_mixed",
            "sbg:category": "Paired-end options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-mixed",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "By default, `hisat2` looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints ([`--fr`/`--rf`/`--ff`], [`-I`], [`-X`]). This option disables that behavior.",
            "label": "Disable dicordant alinments",
            "sbg:toolDefaultValue": "false",
            "id": "#no_discordant",
            "sbg:category": "Paired-end options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-discordant",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Suppress SAM records for reads that failed to align.",
            "label": "Dismiss unaligned reads",
            "sbg:toolDefaultValue": "false",
            "id": "#no_unal",
            "sbg:category": "SAM options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-unal",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Suppress SAM header lines (starting with `@`).",
            "label": "No header",
            "sbg:toolDefaultValue": "false",
            "id": "#no_hd",
            "sbg:category": "SAM options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-hd",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Suppress `@SQ` SAM header lines.",
            "label": "No @SQ lines",
            "sbg:toolDefaultValue": "false",
            "id": "#no_sq",
            "sbg:category": "SAM options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-sq",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Set the read group ID to ``. This causes the SAM `@RG` header line to be printed, with `` as the value associated with the `ID:` tag. It also causes the `RG:Z:` extra field to be attached to each SAM output record, with value set to ``.",
            "label": "Read group ID",
            "id": "#rg_id",
            "sbg:category": "SAM options",
            "type": [
              "null",
              "string"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--rg-id",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Add `` (usually of the form `TAG:VAL`, e.g. `SM:Pool1`) as a field on the `@RG` header line. Note: in order for the `@RG` line to appear, [`--rg-id`] must also be specified. This is because the `ID` tag is required by the SAM specification. Specify this multiple times to set multiple fields. See the SAM file specification for details about what fields are legal.",
            "label": "Read group",
            "id": "#rg",
            "sbg:category": "SAM options",
            "type": [
              "null",
              {
                "items": "string",
                "type": "array",
                "name": "rg"
              }
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--rg",
              "position": 0,
              "itemSeparator": null,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "When printing secondary alignments, HISAT2 by default will write out the `SEQ` and `QUAL` strings. Specifying this option causes HISAT2 to print an asterix in those fields instead.",
            "label": "Omit secondary sequence",
            "sbg:toolDefaultValue": "false",
            "id": "#omit_sec_seq",
            "sbg:category": "SAM options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--omit-sec-seq",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Write `hisat2` metrics to file ``. Having alignment metric can be useful for debugging certain problems, especially performance issues.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#met_file",
            "sbg:category": "Output options",
            "label": "Output metrics file",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--met-file",
              "valueFrom": {
                "script": "{\n\treturn \"metrics.txt\"\n}",
                "class": "Expression",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Causes HISAT2 to run somewhat slower and use somewhat more memory.",
            "label": "Reorder reads",
            "sbg:toolDefaultValue": "false",
            "id": "#reorder",
            "sbg:category": "Performance options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--reorder",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Use `` as the seed for pseudo-random number generator.",
            "label": "Seed",
            "sbg:toolDefaultValue": "0",
            "id": "#seed",
            "sbg:category": "Other options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--seed",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Normally, HISAT2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the [`--seed`] option. This means that if two reads are identical (same name, same nucleotides, same qualities) HISAT2 will find and report the same alignment(s) for both, even if there was ambiguity. When `--non-deterministic` is specified, HISAT2 re-initializes its pseudo-random generator for each read using the current time. This means that HISAT2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "false",
            "id": "#non_deterministic",
            "sbg:category": "Other options",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--non-deterministic",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "In this mode, HISAT2 requires that the entire read align from one end to the other, without any trimming (or \"soft clipping\") of characters from either end. The match bonus `--ma` always equals 0 in this mode, so all alignment scores are less than or equal to 0, and the greatest possible alignment score is 0. This is mutually exclusive with `--local`.  `end_to_end` is the default mode.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#end_to_end",
            "sbg:category": "Alignment options",
            "label": "End-to-end",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--end-to-end",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be concordant.  See also: [Mates can overlap, contain or dovetail each other].  Default: mates cannot dovetail in a concordant alignment.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#dovetail",
            "sbg:category": "Paired-end options",
            "label": "Dovetail",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--dovetail",
              "position": 0,
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "If one mate alignment contains the other, consider that to be non-concordant. See also: [Mates can overlap, contain or dovetail each other].  Default: a mate can contain the other in a concordant alignment.",
            "sbg:stageInput": null,
            "id": "#no_contain",
            "sbg:category": "Paired-end options",
            "label": "No contain",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-contain",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.  See also: [Mates can overlap, contain or dovetail each other].  Default: mates can overlap in a concordant alignment.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#no_overlap",
            "sbg:category": "Paired-end options",
            "label": "No overlap",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--no-overlap",
              "sbg:cmdInclude": true
            }
          },
          {
            "description": "Filter out reads for which the QSEQ filter field is non-zero.  Only has an effect when read format is `--qseq`.  Default: off.",
            "sbg:stageInput": null,
            "sbg:toolDefaultValue": "false",
            "id": "#qc_filter",
            "sbg:category": "Other options",
            "label": "QC filter",
            "type": [
              "null",
              "boolean"
            ],
            "inputBinding": {
              "separate": true,
              "prefix": "--qc-filter",
              "sbg:cmdInclude": true
            }
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:links": [
          {
            "id": "https://ccb.jhu.edu/software/hisat2/manual.shtml#the-hisat2-build-indexer",
            "label": "Homepage"
          },
          {
            "id": "ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/downloads/hisat2-2.0.4-source.zip",
            "label": "Source code"
          },
          {
            "id": "https://wiki.rc.ufl.edu/doc/HISAT2",
            "label": "Wiki"
          },
          {
            "id": "ftp://ftp.ccb.jhu.edu/pub/infphilo/hisat2/downloads/hisat2-2.0.4-source.zip",
            "label": "Download"
          },
          {
            "id": "http://www.nature.com/nmeth/journal/vaop/ncurrent/full/nmeth.3317.html",
            "label": "Publications"
          }
        ],
        "sbg:validationErrors": [],
        "description": "__HISAT2__ is a fast and sensitive alignment program for mapping next-generation sequencing reads (whole-genome, transcriptome, and exome sequencing data) against the general human population (as well as against a single reference genome). Based on GCSA (an extension of BWT for a graph), we designed and implemented a graph FM index (GFM), an original approach and its first implementation to the best of our knowledge. In addition to using one global GFM index that represents general population, HISAT2 uses a large set of small GFM indexes that collectively cover the whole genome (each index representing a genomic region of 56 Kbp, with 55,000 indexes needed to cover human population). These small indexes (called local indexes) combined with several alignment strategies enable effective alignment of sequencing reads. This new indexing scheme is called Hierarchical Graph FM index (HGFM). We have developed HISAT 2 based on the HISAT and Bowtie2 implementations. HISAT2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. SAMtools, GATK) that use SAM.",
        "stdout": "",
        "sbg:createdBy": "marko_zecevic",
        "sbg:modifiedOn": 1472054931,
        "label": "HISAT2",
        "sbg:modifiedBy": "marko_zecevic",
        "sbg:revision": 1,
        "stdin": "",
        "sbg:license": "GPLv3 license",
        "arguments": [
          {
            "separate": true,
            "prefix": "-S",
            "position": 3,
            "valueFrom": {
              "script": "{\n\treturn $job.inputs.reads[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(0,-1).join(\".\")+\".HISAT-2.0.1.aligned.sam\"\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "prefix": "",
            "position": 0,
            "valueFrom": {
              "script": "{\t\n  \tcmd=\"\"\n\tvar reads = [].concat($job.inputs.reads)\n    ext = reads[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-1)[0]\n    if (ext == 'bz2' | ext == 'gz'){\n    \text = reads[0].path.split(\"/\").slice(-1)[0].split(\".\").slice(-2)[0]\n    }\n  \tif (ext == 'txt' & $job.inputs.qseq){\n  \t\tcmd = '--qseq'\n  \t}\n  \telse if (ext == 'fa' | ext == 'fasta' | ext == 'mfa'){\n  \t\tcmd = '-f'\n  \t}\n  \telse if (ext == 'txt' & $job.inputs.raw){\n  \t\tcmd = '-r'\n  \t}\t\n  \treturn cmd\n\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          },
          {
            "separate": true,
            "prefix": "-p",
            "valueFrom": {
              "script": "{\n\treturn $job.allocatedResources.cpu\n}",
              "class": "Expression",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:toolkit": "HISAT2"
      },
      "id": "#HISAT2",
      "sbg:x": 843.7500000000001,
      "outputs": [
        {
          "id": "#HISAT2.out_align"
        },
        {
          "id": "#HISAT2.novel_ss_out"
        },
        {
          "id": "#HISAT2.metrics_file"
        }
      ],
      "inputs": [
        {
          "id": "#HISAT2.reads",
          "source": [
            "#SBG_FASTQ_Quality_Detector.result"
          ]
        },
        {
          "id": "#HISAT2.indexed_reference",
          "source": [
            "#HISAT2_Build_1.tar_out"
          ]
        },
        {
          "id": "#HISAT2.qseq"
        },
        {
          "id": "#HISAT2.raw"
        },
        {
          "id": "#HISAT2.skip"
        },
        {
          "id": "#HISAT2.upto"
        },
        {
          "id": "#HISAT2.trim5"
        },
        {
          "id": "#HISAT2.trim3"
        },
        {
          "id": "#HISAT2.phred64"
        },
        {
          "id": "#HISAT2.intquals"
        },
        {
          "id": "#HISAT2.solexa_quals"
        },
        {
          "id": "#HISAT2.n_ceil"
        },
        {
          "id": "#HISAT2.ignore_quals"
        },
        {
          "id": "#HISAT2.nofw"
        },
        {
          "id": "#HISAT2.norc"
        },
        {
          "id": "#HISAT2.mp"
        },
        {
          "id": "#HISAT2.sp"
        },
        {
          "id": "#HISAT2.np"
        },
        {
          "id": "#HISAT2.rdg"
        },
        {
          "id": "#HISAT2.rfg"
        },
        {
          "id": "#HISAT2.score_min"
        },
        {
          "id": "#HISAT2.pen_cansplice"
        },
        {
          "id": "#HISAT2.pen_noncansplice"
        },
        {
          "id": "#HISAT2.pen_canintronlen"
        },
        {
          "id": "#HISAT2.pen_noncanintronlen"
        },
        {
          "id": "#HISAT2.min_intronlen"
        },
        {
          "id": "#HISAT2.max_intronlen"
        },
        {
          "id": "#HISAT2.known_ss",
          "source": [
            "#HISAT2_ExtractSpliceSites.output_files"
          ]
        },
        {
          "id": "#HISAT2.novel_ss"
        },
        {
          "id": "#HISAT2.novel_ss_in"
        },
        {
          "id": "#HISAT2.no_temp_splicesite"
        },
        {
          "id": "#HISAT2.no_spliced_alignment"
        },
        {
          "id": "#HISAT2.rna_strandness"
        },
        {
          "id": "#HISAT2.transcriptome_only"
        },
        {
          "id": "#HISAT2.downstream_assembly"
        },
        {
          "id": "#HISAT2.dta_cufflinks"
        },
        {
          "id": "#HISAT2.distinct_align"
        },
        {
          "id": "#HISAT2.minins"
        },
        {
          "id": "#HISAT2.maxins"
        },
        {
          "id": "#HISAT2.mate_orientations"
        },
        {
          "id": "#HISAT2.no_mixed"
        },
        {
          "id": "#HISAT2.no_discordant"
        },
        {
          "id": "#HISAT2.no_unal"
        },
        {
          "id": "#HISAT2.no_hd"
        },
        {
          "id": "#HISAT2.no_sq"
        },
        {
          "id": "#HISAT2.rg_id"
        },
        {
          "id": "#HISAT2.rg"
        },
        {
          "id": "#HISAT2.omit_sec_seq"
        },
        {
          "id": "#HISAT2.met_file"
        },
        {
          "id": "#HISAT2.reorder"
        },
        {
          "id": "#HISAT2.seed"
        },
        {
          "id": "#HISAT2.non_deterministic"
        },
        {
          "id": "#HISAT2.end_to_end"
        },
        {
          "id": "#HISAT2.dovetail"
        },
        {
          "id": "#HISAT2.no_contain"
        },
        {
          "id": "#HISAT2.no_overlap"
        },
        {
          "id": "#HISAT2.qc_filter"
        }
      ]
    }
  ],
  "outputs": [
    {
      "required": false,
      "sbg:includeInPorts": true,
      "sbg:y": 60.00000000000001,
      "label": "sorted_bam",
      "id": "#sorted_bam",
      "sbg:x": 1196.666720920139,
      "source": [
        "#Picard_SortSam.sorted_bam"
      ],
      "type": [
        "null",
        "File"
      ]
    }
  ],
  "sbg:image_url": "https://brood.sbgenomics.com/static/marko_zecevic/sbde1/rna-seq-alignment-hisat/6.png",
  "requirements": [],
  "sbg:id": "marko_zecevic/sbde1/rna-seq-alignment-hisat/6",
  "sbg:latestRevision": 6,
  "inputs": [
    {
      "sbg:fileTypes": "FA, FASTA",
      "sbg:y": 303.88536241319446,
      "label": "reference_files",
      "id": "#reference_files",
      "sbg:x": 94.88888210720486,
      "type": [
        {
          "items": "File",
          "type": "array",
          "name": "reference_files"
        }
      ]
    },
    {
      "sbg:includeInPorts": true,
      "sbg:y": 111.10763125949438,
      "label": "fastq",
      "batchType": "metadata.sample_id",
      "id": "#fastq",
      "sbg:x": 90.11110093858507,
      "type": [
        {
          "items": "File",
          "type": "array"
        }
      ]
    },
    {
      "sbg:fileTypes": "GTF",
      "sbg:y": 504.4444783528646,
      "label": "input_GTF",
      "id": "#input_GTF",
      "sbg:x": 105.5555640326606,
      "type": [
        "File"
      ]
    }
  ],
  "hints": [],
  "sbg:revisionsInfo": [
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 0,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472044738
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 1,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472046540
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 2,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472046615
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 3,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472050348
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 4,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472050591
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 5,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472052240
    },
    {
      "sbg:modifiedBy": "marko_zecevic",
      "sbg:revision": 6,
      "sbg:revisionNotes": null,
      "sbg:modifiedOn": 1472054996
    }
  ],
  "sbg:createdOn": 1472044738,
  "sbg:canvas_zoom": 0.7999999999999998,
  "sbg:batchBy": {
    "criteria": [
      "metadata.sample_id"
    ],
    "type": "criteria"
  },
  "sbg:canvas_y": 98,
  "class": "Workflow",
  "sbg:contributors": [
    "marko_zecevic"
  ],
  "sbg:sbgMaintained": false,
  "sbg:validationErrors": [],
  "sbg:batchInput": "#fastq",
  "description": "",
  "sbg:createdBy": "marko_zecevic",
  "sbg:modifiedOn": 1472054996,
  "label": "RNA-seq Alignment - HISAT2",
  "sbg:modifiedBy": "marko_zecevic",
  "sbg:revision": 6,
  "id": "https://api.sbgenomics.com/v2/apps/marko_zecevic/sbde1/rna-seq-alignment-hisat/6/raw/"
}